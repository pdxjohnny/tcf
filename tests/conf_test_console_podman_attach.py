#! /usr/bin/python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#
import os
import pwd
import pathlib
import tempfile
import subprocess

import ttbl
import ttbl.console
import ttbl.power


srcdir = os.path.dirname(__file__)


class podman_rpyc_c(ttbl.power.daemon_c):
    socket_filename = "rpyc.sock"

    def __init__(self, entrypoint_path, podman_path = "/usr/bin/podman",
            **kwargs):
        assert isinstance(entrypoint_path, str), \
            "entrypoint_path: expected a string, got %s" % type(entrypoint_path)
        self.entrypoint_path = entrypoint_path

        if podman_path:
            self.podman_path = podman_path
        assert isinstance(self.podman_path, str), \
            "podman_path: expected a string, got %s" % type(self.podman_path)

        cmdline = [
            self.podman_path,
            "run",
            "--rm",
            "-i",
            "-e",
            f"SOCKET_PATH=/rpyc/{self.socket_filename}",
            "-e",
            "UID=%(uid)s",
            "-e",
            "GID=%(gid)s",
            "-v",
            "%(socket_dir)s:/rpyc/:rw",
            "-v",
            f"{entrypoint_path}:/entrypoint.py:ro",
            "--name",
            "%(container_name)s",
            "docker.io/library/python:3",
            "python",
            "-u",
            "/entrypoint.py",
        ]
        ttbl.power.daemon_c.__init__(
            self, cmdline, precheck_wait = 0.5, mkpidfile = True,
            name = "podman", **kwargs
        )
        self.upid_set("Podman RPyC")
        self.name = "podman"


    def verify(self, target, component, _cmdline_expanded):
        # pidfile has been generated by ttbl.power.daemon_c from the
        # default template PATH/COMPONENT-NAME.pid (see doc)
        # note we get the NAME set in the construtore
        pidfile = os.path.join(target.state_dir, component + "-podman.pid")
        # we first check if the process is running, then the port;
        # FIXME: there is a chance the daemon is restarting and hasn't
        # fire up the port listener yet
        return commonl.process_alive(pidfile, self.path)


    def _kill_container(self):
        subprocess.call([
            self.podman_path,
            "kill",
            "--signal",
            "KILL",
            self.kws["container_name"],
        ])


    def on(self, target, component):
        # Set the container name
        self.kws["container_name"] = f"{target.id}_{component}"
        # Kill first, make sure no lingering processes around
        self._kill_container()
        # Create a temporary directory for the socket
        self.kws["socket_dir"] = tempfile.mkdtemp()
        # Get the user idsid so we can lookup that users uid for a chown
        user = ttbl.user_control.User.search_user(target.owner_get())
        print(user)
        # TODO DEBUG Remove this in favor of None as default
        idsid = user.fsdb.get("data.IDSID", "johnsa1")
        # idsid = user.fsdb.get("data.IDSID", None)
        if idsid is None:
            raise Exception("Target must have idsid")
        # Set the uid we need to chown the created socket
        pw = pwd.getpwnam(idsid)
        self.kws["uid"] = pw.pw_uid
        self.kws["gid"] = pw.pw_gid
        # Start it
        ttbl.power.daemon_c.on(self, target, component)
        # Put path to socket in inventory
        target.fsdb.set(
            "podman_rpyc." + component + ".socket_path",
            os.path.join(self.kws["socket_dir"], self.socket_filename),
        )


    def off(self, target, component):
        ttbl.power.daemon_c.off(self, target, component)
        # Remove the temporary directory for the socket
        shutil.rmtree(self.kws["socket_dir"])
        del self.kws["socket_dir"]
        # just in case, kill it hard
        self._kill_container()
        del self.kws["container_name"]


def inpath(binary):
    return any(
        list(
            map(
                lambda dirname: os.path.isfile(os.path.join(dirname, binary)),
                os.environ.get("PATH", "").split(":"),
            )
        )
    )


target = ttbl.test_target("t0")
ttbl.config.target_add(target)
target.interface_add("power", ttbl.power.interface(
    p1 = podman_rpyc_c(
        os.environ["ENTRYPOINT_PATH"],
        podman_path = "/usr/bin/docker" if not inpath("podman") else None
    ),
))
